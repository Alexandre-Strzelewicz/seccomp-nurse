
I got SECCOMPed and all I got was theses syscalls: read, write,
sigreturn and _exit.

* System calls
*** Processor implementation

  On x86, userspace processes run in ring 3, while the kernel is in
  ring 0. Only the kernel can do the interface between the resources
  and the processes.

  A resource can be an access to a hardware device, a kernel object or
  any kind of IPC. In other words, each time it is needed to do such
  action, the userspace application has to make a request to the
  kernel; this is what we call a system call (syscall), basically,
  this is the transition from a ring to another one.

  Historically, on Linux and x86, the best known method for performing
  a syscall is to generate an interruption (the classic =int $0x80=
  instruction) which is trapped by the kernel and then processed.

  It was the most efficient way until the Pentium 4, after that, it
  became the slowest mechanism available (XXX, give the reference to
  the benchmark on LKML). The best method became the sysenter/sysexit
  instructions on x86_32.

  On AMD64, a similar mechanism exists: syscall/sysret.

#+BEGIN_src asm
  XXX: Add here a minimalist example of sysenter/sysexit
#+END_src

  Usually, except shellcodes, syscalls are generated by the libc and
  depending on the processor, using one solution or another can have
  strong impact on performances but Linux distributions provide only
  one compiled version of the libc: it has to run equally well on all
  CPU versions. Thus, there was a need of an abstraction layer which
  would be called by the libc and which would choose the best
  mechanism at runtime.

  This is the kernel's job: the kernel is compiled with all mechanisms
  and selects the best one at boot time. Once a method is chosen, it
  exposes a function to userspace calling directly the selected
  methods. This way of exposing page is called a Virtual Dynamically
  Shared Object, or VDSO.

  In the libc, a system call is just a matter of calling a function.

  Here is a call to =_exit()=:

#+BEGIN_src asm
  movl $1, %eax   ; __NR_exit = 1
  movl $0, %ebx   ; status    = 0
  call *%gs:0x10  ; Here, the offset (0x10) is platform-dependent
                  ; The memory page %gs:0x10 is located in the VDSO
#+END_src

*** VDSO

  A VDSO is a page maintained by the kernel and exposed to userspace
  by mapping this page into its address space as we can it in the
  mapping file:

#+BEGIN_verbatim
$ cat /proc/self/maps
08048000-08051000 r-xp 00000000 fd:01 14450888   /bin/cat
08051000-08052000 rw-p 00009000 fd:01 14450888   /bin/cat
083d7000-083f8000 rw-p 00000000 00:00 0          [heap]
b7475000-b7633000 r--p 00000000 fd:01 592041     /usr/lib/locale/locale-archive
b7633000-b7634000 rw-p 00000000 00:00 0 
b7634000-b7775000 r-xp 00000000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
b7775000-b7777000 r--p 00141000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
b7777000-b7778000 rw-p 00143000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
b7778000-b777b000 rw-p 00000000 00:00 0 
b7794000-b7796000 rw-p 00000000 00:00 0 
b7796000-b7797000 r-xp 00000000 00:00 0          [vdso]
b7797000-b77b3000 r-xp 00000000 fd:01 2818106    /lib/ld-2.10.2.so
b77b3000-b77b4000 r--p 0001b000 fd:01 2818106    /lib/ld-2.10.2.so
b77b4000-b77b5000 rw-p 0001c000 fd:01 2818106    /lib/ld-2.10.2.so
bfafd000-bfb12000 rw-p 00000000 00:00 0          [stack]
#+END_verbatim

  Here, the VDSO is one page long (0x1000, or 4096 bytes). It contains
  the syscall interface, but also some shared variables (low level
  information like rdtsc counter or real time timer, stack canary,),
  etc.

  The selection of the right method is done in
  =arch/x86/vdso/vdso32-setup.c= in the =sysenter_setup= function
  (which is called very early in the kernel initialization by
  =identify_boot_cpu()=).

#+BEGIN_src c
  int __init sysenter_setup(void)
  {
      void *syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);
      const void *vsyscall;
      size_t vsyscall_len;
  
      vdso32_pages[0] = virt_to_page(syscall_page);
  
  #ifdef CONFIG_X86_32
      gate_vma_init();
  #endif
  
      if (vdso32_syscall()) {
          vsyscall = &vdso32_syscall_start;
          vsyscall_len = &vdso32_syscall_end - &vdso32_syscall_start;
      } else if (vdso32_sysenter()){
          vsyscall = &vdso32_sysenter_start;
          vsyscall_len = &vdso32_sysenter_end - &vdso32_sysenter_start;
      } else {
          vsyscall = &vdso32_int80_start;
          vsyscall_len = &vdso32_int80_end - &vdso32_int80_start;
      }
  
      memcpy(syscall_page, vsyscall, vsyscall_len);
      relocate_vdso(syscall_page);
  
      return 0;
  }
#+END_src

  The implementation of the sysenter instruction is in
  =arch/x86/vdso/vdso32/sysenter.S=. The routine called by the libc
  (with the =call *%gs:0x10=) is named =__kernel_vsyscall= :

#+BEGIN_src asm
  __kernel_vsyscall:
  .LSTART_vsyscall:
      push %ecx
  .Lpush_ecx:
      push %edx
  .Lpush_edx:
      push %ebp
  .Lenter_kernel:
      movl %esp,%ebp
      sysenter
    /* 7: align return point with nop's to make disassembly easier */
    .space 7,0x90

    /* 14: System call restart point is here! (SYSENTER_RETURN-2) */
    jmp .Lenter_kernel
    /* 16: System call normal return point is here! */
VDSO32_SYSENTER_RETURN: /* Symbol used by sysenter.c via vdso32-syms.h */
    pop %ebp
.Lpop_ebp:
    pop %edx
.Lpop_edx:
    pop %ecx
.Lpop_ecx:
    ret
#+END_src

  Linus Torvalds is the proud owner of this code because he managed to
  handle the system call restarting thanks to a CPU particularity:
  when the kernel is done with a system call and want to give back the
  control to the process, it just have to perform the =sysexit=
  instruction. 

  Prior to that, the kernel specified to the CPU that at sysexit time,
  it has to jump to a specific static address. This address is the
  =VDSO32_SYSENTER_RETURN= routine.

  XXX for the restart case.


*** Kernel side

  =arch/x86/kernel/entry_32.S= => syscall
  Retour à une adresse fixe. VDSO32_SYSENTER_RETURN
  

* Limitations

  - x86_32
  - VDSO

* SECCOMP

       PR_SET_SECCOMP (since Linux 2.6.23)
              Set the secure computing mode for the calling  thread.   In  the
              current  implementation,  arg2 must be 1.  After the secure com‐
              puting mode has been set to 1, the only system  calls  that  the
              thread is permitted to make are read(2), write(2), _exit(2), and
              sigreturn(2).  Other system calls result in the  delivery  of  a
              SIGKILL  signal.   Secure  computing  mode is useful for number-
              crunching applications that may need to execute  untrusted  byte
              code,  perhaps  obtained by reading from a pipe or socket.  This
              operation is only available if the  kernel  is  configured  with
              CONFIG_SECCOMP enabled.
